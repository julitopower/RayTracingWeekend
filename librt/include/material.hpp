#ifndef MATERIAL_HPP
#define MATERIAL_HPP

#include <map>
#include <memory>
#include <string>

#include <vector.hpp>
#include <texture.hpp>

namespace rt {

class Hit;
class Ray;

/*!
 * \brief Abstract representation of a material that can be associated with
 *        a object. Material is also used to decorate a Hit.
 */
class Material {
 public:
  /*!
   * \brief Scatter an incoming Ray using Hit information, and attenuation vector
   *
   * \param ray The incoming Ray
   * \param hit Information about the intersection between the Ray and a Hitable
   * \param attenuation Vector representing the attenuation factor to be applied to each color
   * \param scattered Output parameter. Ray generated by the scatter calculation
   * \return
   */
  virtual bool scatter(const Ray& ray,
                       const Hit& hit,
                       Vector3f&  attenuation,
                       Ray& scattered) const = 0;

  virtual ~Material(){};
};

/*!
 * \brief A non reflecting material
 */
class Lambertian : public Material {
 public:
  /*!
   * \brief Construct a new Lambertian material with the given attenuation vector
   */
  explicit Lambertian(Texture* a) : albedo_{a} {}

  /*
   * Generate a scattered Ray in a random direction. Given an intersection point a
   * nd a normal with unit length, the scattered ray is calculated by moving the
   * intersection point in the direction of the normal, for the length of the
   * normal, and then moving it along a unit vector in a random direction.
   */
  bool scatter(const Ray& ray,
               const Hit& rec,
               Vector3f& attenuation,
               Ray& scattered) const final override;
 private:
  Texture* albedo_;
};

class Metal : public Material {
 public:
  explicit Metal(const Vector3f& a) : albedo_{a}{}

  bool scatter(const Ray& ray,
               const Hit& rec,
               Vector3f& attenuation,
               Ray& scattered) const final override;
 private:
  Vector3f albedo_;
};

/*!
 * \brief A non reflecting material
 */
class Dielectric : public Material {
 public:
  /*!
   * \brief Construct a new Lambertian material with the given attenuation vector
   */
  explicit Dielectric(float ri) : ref_idx_{ri} {}

  /*
   * Generate a scattered Ray in a random direction. Given an intersection point a
   * nd a normal with unit length, the scattered ray is calculated by moving the
   * intersection point in the direction of the normal, for the length of the
   * normal, and then moving it along a unit vector in a random direction.
   */
  bool scatter(const Ray& ray,
               const Hit& rec,
               Vector3f& attenuation,
               Ray& scattered) const final override;
 private:
  float ref_idx_;
};

class MaterialRegistry {
 public:
  MaterialRegistry() = default;
  void register_lambertian(const std::string& name,
                           Texture* attenuation);
  
  void register_metal(const std::string& name,
                      const Vector3f& attenuation);

  void register_dielectric(const std::string& name,
                           float ref_idx);

  Material* get(const std::string& name);
  
  Material* generate_lambertial(rt::TextureRegistry& textures) {
    random_.push_back(std::make_unique<Lambertian>(textures.random_color()));
    return random_.back().get();
  }

  Material* generate_metal() {
    auto dis = std::uniform_real_distribution<float>{0.0, 1.0};
    std::random_device device;      
    random_.push_back(
        std::make_unique<Metal>(rt::Vector3f{0.5f * (1 + dis(device)),
                0.5f * (1 + dis(device)),
                0.5f * dis(device)}));
    return random_.back().get();
  }

  Material* generate_dielectric() {
    random_.push_back(std::make_unique<Dielectric>(1.5));
    return random_.back().get();
  }    
 private:
  std::map<std::string, std::unique_ptr<Material>> registry_;
  std::vector<std::unique_ptr<Material>> random_;
};

} // namespace rt

#endif // MATERIAL_HPP
