#ifndef MATERIAL_HPP
#define MATERIAL_HPP

#include <map>
#include <memory>
#include <string>

#include <vector.hpp>

namespace rt {

class Ray;
class Hit;

/*!
 * \brief Abstract representation of a material that can be associated with
 *        a object. Material is also used to decorate a Hit.
 */
class Material {
 public:
  /*!
   * \brief Scatter an incoming Ray using Hit information, and attenuation vector
   *
   * \param ray The incoming Ray
   * \param hit Information about the intersection between the Ray and a Hitable
   * \param attenuation Vector representing the attenuation factor to be applied to each color
   * \param scattered Output parameter. Ray generated by the scatter calculation
   * \return
   */
  virtual bool scatter(const Ray& ray,
                       const Hit& hit,
                       Vector3f&  attenuation,
                       Ray& scattered) const = 0;

  virtual ~Material(){};
};

/*!
 * \brief A non reflecting material
 */
class Lambertian : public Material {
 public:
  /*!
   * \brief Construct a new Lambertian material with the given attenuation vector
   */
  explicit Lambertian(const Vector3f& a) : albedo_{a} {}

  /*
   * Generate a scattered Ray in a random direction. Given an intersection point a
   * nd a normal with unit length, the scattered ray is calculated by moving the
   * intersection point in the direction of the normal, for the length of the
   * normal, and then moving it along a unit vector in a random direction.
   */
  bool scatter(const Ray& ray,
               const Hit& rec,
               Vector3f& attenuation,
               Ray& scattered) const final override;
 private:
  Vector3f albedo_;
};

class Metal : public Material {
 public:
  explicit Metal(const Vector3f& a) : albedo_{a}{}

  bool scatter(const Ray& ray,
               const Hit& rec,
               Vector3f& attenuation,
               Ray& scattered) const final override;
 private:
  Vector3f albedo_;
};

class MaterialRegistry {
 public:
  MaterialRegistry() = default;
  void register_lambertian(const std::string& name,
                           const Vector3f& attenuation);
  
  void register_metal(const std::string& name,
                      const Vector3f& attenuation);

  Material* get(const std::string& name);
 private:
  std::map<std::string, std::unique_ptr<Material>> registry_;
};

} // namespace rt

#endif // MATERIAL_HPP
